# Python 数据类型和结构

在本章中，我们将详细研究 Python 数据类型。我们已经介绍了两种数据类型，字符串、`str()`和`list()`。通常情况下，我们需要更专门的对象来表示数据。除了内置类型之外，还有几个内部模块，允许我们在处理数据结构时解决常见问题。首先，我们将回顾所有数据类型通用的一些操作和表达式。

# 运算和表达式

有许多操作对于所有数据类型都是通用的。例如，所有数据类型，通常所有对象，都可以通过某种方式测试真值。以下是 Python 考虑的值`False`：

*   `None`型
*   `False`
*   整数、浮点或复数零
*   空序列或映射
*   用户定义类的一个实例，该类定义返回零或 T2 的`__len__()`或`__bool__()`方法

所有其他值均被视为`True`。

# 布尔运算

布尔运算返回的值为`True`或`False`。布尔运算按优先级排序，因此，如果表达式中发生多个布尔运算，则优先级最高的运算将首先发生。下表按优先级降序列出了三个布尔运算符：

| **操作员** | **示例** |
| 不是`x` | 如果`x`为`False`，则返回`True`；否则返回`False`。 |
| `x`和`y` | 如果`x`和`y`都是`True`，则返回`True`；否则返回`False`。 |
| `x`或`y` | 如果`x`或`y`为`True`，则返回`True`；否则返回`False`。 |

`and`运算符和`or`运算符在计算表达式时都使用“短路”。这意味着 Python 只会在需要时对操作符求值。例如，如果`x`是`True`，那么在表达式`x`或`y`中，`y`不会得到计算，因为该表达式显然是`True`。类似地，在表达式`x`和`y`中`x`是`False`，解释器将简单地计算`x`并返回`False`，而不计算`y`。

# 比较和算术运算符

标准算术运算符（`+`、`-`、`*`、`/`可用于所有 Python 数字类型。`//`运算符给出一个整数商，（例如，`3 // 2`返回`1`），指数运算符为`x ** y`，模运算符由`a % b`给出，返回除法的剩余部分`a/b`。比较运算符（`<`、`<=`、`>`、`>=`、`==`和`!=`处理数字、字符串、列表和其他收集对象，如果条件成立，则返回`True`。对于集合对象，这些运算符比较元素的数量，如果每个集合对象在结构上是等价的，并且每个元素的值都相同，则等价运算符`== b`返回`True`。

# 成员资格、标识和逻辑操作

成员身份运算符（`in`、`not in`测试序列中的变量，如列表或字符串，执行您预期的操作，`x in y`如果在`y`中找到变量`x`，则返回`True`。`is`运算符比较对象标识。例如，以下代码段显示了与对象标识的对比度等价性：

![](assets/256c6c6d-7930-4249-b954-b16ec8bd45bf.png)

# 内置数据类型

Python 数据类型可以分为三类：数值型、序列型和映射型。还有表示`Null`的`None`对象，或者表示没有值。也不要忘记，类、文件和异常等其他对象也可以适当地视为*类型*；但是，这里不考虑这些问题。

Python 中的每个值都有一个数据类型。与许多编程语言不同，在 Python 中，不需要显式声明变量的类型。Python 在内部跟踪对象类型。

下表概述了 Python 内置数据类型：

| **类别** | **名称** | **说明** |
| 没有一个 | `None` | 空对象。 |
| 数字的 | `int` | 整数 |
|  | `float` | 浮点数。 |
|  | `complex` | 复数。 |
|  | `bool` | 布尔值（真、假）。 |
| 序列 | `str` | 字符串。 |
|  | `list` | 任意对象的列表。 |
|  | `Tuple` | 一组任意项目。 |
|  | `range` | 创建一个整数范围。 |
| 映射 | `dict` | 键值对字典。 |
|  | `set` | 独特项目的易变、无序集合。 |
|  | `frozenset` | 不变集。 |

# 无类型

None 类型是不可变的，只有一个值`None`。它用于表示缺少值。它由不显式返回值并在布尔表达式中计算为`False`的对象返回。它通常用作可选参数中的默认值，以允许函数检测调用方是否传递了值。

# 数值类型

除`bool`之外的所有数字类型都是有符号的，它们都是不可变的。布尔值有两个可能的值，`True`和`False`。这些值分别映射到 1 和 0。整数类型`int`表示无限范围的整数。浮点数由机器的本机双精度浮点数表示。复数由两个浮点数表示。它们使用`j`运算符来表示复数的虚部，例如：

```
a = 2+3j
```

我们可以分别使用`a.real`和`a.imag`访问实部和虚部。

# 表示错误

应该注意的是，浮点数的本机双精度表示会导致一些意外的结果。例如，考虑以下内容：

![](assets/cab23e95-2a2a-4ba0-9503-ff6b4488634a.png)

这是因为大多数十进制分数不能精确地表示为二进制分数，这就是大多数底层硬件表示浮点数的方式。对于可能存在此问题的算法或应用程序，Python 提供了一个`decimal`模块。此模块允许精确表示十进制数，并有助于更好地控制特性，如舍入行为、有效位数和精度。它定义了两个对象，`Decimal`类型表示十进制数，`Context`类型表示各种计算参数，如精度、舍入和错误处理。在以下代码段中可以看到其用法示例：

![](assets/c17729f2-5680-4246-90c9-914a3f1176ff.png)

在这里，我们创建了一个全局上下文，并将精度设置为`4`。`Decimal`对象可以像对待`int`或`float`一样对待。它们接受所有相同的数学运算，可以用作字典键、放置在集合中，等等。此外，`Decimal`对象还有几种数学运算方法，如自然指数、`x.exp()`、自然对数、`x.ln()`和以 10 为底的对数、`x.log10()`。

Python 还有一个实现有理数类型的`fractions`模块。以下示例显示了创建分数的几种方法：

![](assets/774f409e-72f7-455b-baf1-aec7ac850155.png)

这里还值得一提的是`NumPy`扩展。它具有数组、向量和矩阵等数学对象的类型，以及线性代数、傅立叶变换计算、特征向量、逻辑运算等功能。

# 序列

序列是由非负整数索引的有序对象集。列表和元组是任意对象的序列，字符串是字符序列。字符串、元组和范围对象是不可变的。所有序列类型都有许多共同的操作。对于所有序列，如前一章所述，索引和切片运算符适用。请注意，对于不可变类型，任何操作都只会返回一个值，而不会实际更改该值。

所有序列都有以下方法：

| **方法** | **说明** |
| `len(s)` | `s`中的元素数量 |
| `min(s, [,default=obj, key=func])` | `s`中的最小值（字符串按字母顺序排列） |
| `max(s, [,default=obj, key=func])` | `s`中的最大值（字符串按字母顺序排列） |
| `sum(s,[,start=0])` | 元素之和（如果`s`不是数字，则返回`TypeError`） |
| `all(s)` | 如果`s`中的所有元素都为真（即不是`0`、`False`或`Null`返回`True` |
| `any(s)` | 检查`s`中是否有`True`项 |

此外，所有序列都支持以下操作：

| **操作** | **说明** |
| `s + r` | 连接相同类型的两个序列 |
| `s * n` | 制作`s`的`n`份，其中`n`为整数 |
| `v1, v2 ..., vn = s` | 将 n 个变量从`s`解压到`v1`、`v2`等 |
| `s[i]` | 索引返回`s`中的元素`i` |
| `s[i:j:stride]` | 切片返回`i`和`j`之间的元素，可选择步长 |
| `x in s` | 如果元素`x`在`s`中，则返回`True` |
| `x not in s` | 如果元素`x`不在`s`中，则返回 true |

# 多元组

元组是任意对象的不可变序列。它们由大于零的整数索引。元组是**可散列的**，这意味着我们可以对它们的列表进行排序，它们可以用作字典的键。语法上，元组只是一个逗号分隔的值序列；然而，通常的做法是将它们括在括号内：

```
tpl= ('a', 'b', 'c') 
```

在创建包含一个元素的元组时，务必记住使用尾随逗号，例如：

```
t = ('a',) 
```

如果没有尾随逗号，这将被解释为字符串。

我们还可以使用内置函数`tuple()`创建元组。在没有参数的情况下，这将创建一个空元组。如果`tuple()`的参数是一个序列，则会创建该序列元素的元组，例如：

![](assets/71645f5a-0593-4961-b7f6-e328d41daafe.png)

大多数操作符（例如用于切片和索引的操作符）的工作方式与它们在列表上的工作方式相同。然而，由于元组是不可变的，尝试修改元组的一个元素将得到一个`TypeError.`我们可以使用`==`、`>`和`<`操作符，以与比较其他序列相同的方式来比较元组。

元组的一个重要用途是通过将元组放置在赋值的左侧，允许我们一次赋值多个变量，例如：

![](assets/bf860c36-7224-4982-877c-4559fe280c7e.png)

实际上，我们可以使用此多重赋值来交换元组中的值，例如：

![](assets/acf02c37-b462-43b7-ab38-dbb6625294e7.png)

如果赋值的每一侧上的值的数目不相同，将抛出一个`ValueError`。

# 辞典

字典是由数字、字符串或其他不可变对象索引的对象的任意集合。字典本身是可变的；但是，它们的索引键必须是不可变的。下表包含所有字典方法及其说明：

| **方法** | **说明** |
| `len(d)` | `d`中的项目数。 |
| `d.clear()` | 从`d`中删除所有项目。 |
| `d.copy()` | 制作`d`的浅显副本。 |
| `d.fromkeys(s [,value])` | 返回一个新字典，其中包含序列`s`中的键和设置为`value`的值。 |
| `d.get(k [,v])` | 如果找到返回`d[k]`，否则返回`v`，如果没有给出`v`，则返回无。 |
| `d.items()` | 返回`d`中的`key:value`对序列。 |
| `d.keys()` | 返回`d`中的键序列。 |
| `d.pop(k [,default])` | 返回`d[k]`并将其从`d`中删除。如果未找到`d[k]`，则返回默认值或引发`KeyError`。 |
| `d.popitem()` | 从`d`中移除随机`key:value`对，并将其作为元组返回。 |
| `d.setdefault(k [,v])` | 返回`d[k]`。如果没有找到`d[k]`，则返回`v`并将`d[k]`设置为`v`。 |
| `d.update(b)` | 将所有对象从`b`添加到`d`。 |
| `d.values()` | 返回`d`中的一系列值。 |

Python 字典是唯一的内置映射类型，它们类似于其他语言中的哈希表或关联数组。可以将它们视为从一组键到一组值的映射。它们是使用语法`{key:value}`创建的。例如，下面创建一个字典，将单词映射到数字：

```
d ={'one': 1 , 'two': 2, 'three': 3 } # creates a dictionary 
```

我们可以按如下方式添加键和值：

```
d['four']=4 #add an item 
```

或使用以下命令更新多个值：

```
d.update({'five': 5, 'six': 6}) #add multiple items 
```

当我们检查`d`时，我们得到以下信息：

![](assets/b9f872f6-a5d6-4e8a-a849-cd15abb50af6.png)

我们可以使用`in`运算符测试值的出现情况，例如：

![](assets/370938be-5598-4a01-bef6-0be2c56d51da.png)

需要注意的是，`in`运算符应用于词典时，其工作方式与应用于列表时略有不同。当我们在列表上使用`in`运算符时，查找元素所需的时间与列表大小之间的关系被认为是线性的。也就是说，随着列表的大小变大，查找元素所需的相应时间最多呈线性增长。算法运行时间与其输入大小之间的关系通常被称为其时间复杂度。我们将在下一章（及后续章节）中更多地讨论这一重要主题。

与`list`对象不同，当`in`操作符应用于字典时，它使用哈希算法，这会导致每次查找的时间增加，几乎与字典的大小无关。这使得字典作为处理大量索引数据的一种方式非常有用。我们将在[第 4 章](04.html)、*列表和指针结构*和[第 13 章](13.html)、*实现、应用程序和工具*中进一步讨论增长率哈希这一重要话题。

请注意，当我们打印出字典的`key:value`对时，它没有特定的顺序。这不是问题，因为我们使用指定的键来查找每个字典值，而不是像字符串和列表那样使用整数的有序序列。

# 分类词典

如果要对字典的键或值进行简单排序，可以执行以下操作：

![](assets/59977056-8e66-4a02-9939-d031cb9a5371.png)

请注意，前面代码中的第一行按照字母顺序对键进行排序，第二行按照整数值顺序对值进行排序。

`sorted()`方法有两个值得关注的可选参数：`key`和`reverse`。key 参数与 dictionary 键无关，而是将函数传递给 sort 算法以确定排序顺序的一种方式。例如，在下面的代码中，我们使用`__getitem__`特殊方法根据字典值对字典键进行排序：

![](assets/6f817c63-7043-45a0-9442-71aaaf47aa6d.png)

本质上，前面的代码所做的是让`d`中的每个`key`使用相应的值进行排序。我们还可以根据字典键的排序顺序对值进行排序。但是，由于字典没有通过使用其值返回`key`的方法，因此使用可选的`key`参数来返回`key`与列表的`list.index`方法相当，这有点棘手。另一种方法是使用列表理解，如下例所示：

![](assets/623d5914-8833-4643-a013-b3882482f3e6.png)

`sorted()`方法也有一个可选的反向参数，不出所料，它完全按照它所说的做，反转排序列表的顺序，例如：

![](assets/e0433fa9-ebd3-4438-8f55-8decd8ef99de.png)

现在，假设我们得到了以下词典，英语单词作为关键字，法语单词作为值。我们的任务是将这些字符串值按正确的数字顺序排列：

```
d2 ={'one':'uno' , 'two':'deux', 'three':'trois', 'four': 'quatre', 'five': 'cinq', 'six':'six'}
```

当然，当我们打印这本词典时，它不可能按正确的顺序打印。因为所有键和值都是字符串，所以我们没有数字排序的上下文。为了将这些项目按正确顺序排列，我们需要使用我们创建的第一本词典，将单词映射到数字，以此将我们的英语词典排序为法语词典：

![](assets/ced1a2c2-fd41-43cf-b631-8ca367e1927b.png)

请注意，我们使用第一个字典`d`的值对第二个字典`d2`的键进行排序。由于两个词典中的键相同，我们可以使用列表理解对法语到英语词典的值进行排序：

![](assets/aa0723e7-d005-4e1b-85d9-a6a53f30833c.png)

当然，我们可以定义自己的自定义方法，将其用作`sorted`方法的`key`参数。例如，这里我们定义了一个函数，它只返回字符串的最后一个字母：

```
def corder(string): 

   return(string[len(string)-1]) 
```

然后，我们可以将其用作我们的`sorted`函数的`key`，按照每个元素的最后一个字母对其进行排序：

![](assets/383ff5cc-9f91-4b61-921e-49c361d7822c.png)

# 文本分析词典

字典的一个常见用法是按顺序计算相似项的出现次数；一个典型的例子是计算正文中单词的出现次数。下面的代码创建一个字典，其中文本中的每个单词都用作键，出现的次数作为其值。这使用了一种非常常见的嵌套循环习惯用法。在这里，我们使用它在外循环中遍历文件中的行，在内循环中遍历字典的键：

```
def wordcount(fname): 
    try: 
        fhand=open(fname) 
    except: 
        print('File cannot be opened') 
        exit() 

    count= dict() 
    for line in fhand: 
        words = line.split() 
        for word in words: 
            if word not in count: 
                count[word] = 1 
            else: 
                count[word] += 1 
    return(count) 
```

这将返回一个字典，其中包含文本文件中每个唯一单词的元素。一个常见的任务是将这些项过滤到我们感兴趣的子集中。在运行代码时，需要在同一目录中保存一个文本文件。这里我们使用了`alice.txt`，这是*爱丽丝梦游仙境*中的一小段摘录。要获得相同的结果，您可以从[davejulian.net/bo5630](http://davejulian.net/bo5630)下载`alice.txt`，或者使用您自己的文本文件。在下面的代码中，我们创建了另一个字典`filtered`，其中包含来自`count`的项目子集：

```
count=wordcount('alice.txt') 
filtered = { key:value for key, value in count.items() if value  < 20 and value > 15 } 
```

打印过滤后的词典时，我们会得到以下结果：

![](assets/f1921be2-143a-4ad1-955e-4167ef9ab6d0.png)

注意用于构建过滤字典的**字典理解**的使用。字典理解的工作方式与我们在[第 1 章](01.html)、*Python 对象、类型和表达式*中看到的列表理解的工作方式相同。

# 设置

集合是唯一项的无序集合。集合本身是可变的，我们可以添加和删除其中的项；但是，项目本身必须是不可变的。集合的一个重要区别是它们不能包含重复的项。集合通常用于执行数学运算，例如交集、并集、差集和补集。

与序列类型不同，集合类型不提供任何索引或切片操作。与字典一样，也没有与值关联的键。Python 中有两种类型的 set 对象，可变的`set`对象和不可变的`frozenset`对象。集合是使用花括号中逗号分隔的值创建的。顺便说一下，我们不能使用`a={}`创建一个空集，因为这将创建一个字典。要创建一个空集，我们可以编写`a=set()`或`a=frozenset()`。

集合的方法和操作如下表所示：

| **方法** | **操作员** | **说明** |
| `len(s)` |  | 返回`s`中的元素数 |
| `s.copy()` |  | 返回`s`的浅层副本 |
| `s.difference(t)` | `s - t- t2 - ...` | 返回一组在`s`中但不在`t`中的所有项目 |
| `s.intersection(t)` |  | 返回`t`和`s`中所有项目的集合 |
| `s.isdisjoint(t)` |  | 如果`s`和`t`没有共同项，则返回 True |
| `s.issubset(t)` | `s <= t``s < t (s != t)` | 如果`s`中的所有项目也在`t`中，则返回 True |
| `s.issuperset(t)` | `s >= t``s > t (s != t)` | 如果`t`中的所有项目也在`s`中，则返回 True |
| `s.symmetric_difference(t)` | `s ^ t` | 返回一组在`s`或`t`中的所有项目，但不能同时返回这两个项目 |
| `s.union(t)` | `s &#124; t1 &#124; t2 &#124;...` | 返回`s`或`t`中所有项目的集合 |

在上表中，参数`t`可以是任何支持迭代的 Python 对象，并且所有方法都可用于`set`和`frozenset`对象。需要注意的是，这些方法的运算符版本要求其参数为集合，而这些方法本身可以接受任何 iterable 类型。例如，对于任何集合`s`，将生成不支持的操作数类型`s - [1,2,3]`。使用等效的`s.difference([1,2,3])`将返回一个结果。

可变集对象具有其他方法，如下表所述：

| **方法** | **说明** |
| `s.add(item)` | 将项目添加到`s`。如果`item`已经存在，则无效。 |
| `s.clear()` | 从`s`中删除所有项目。 |
| `s.difference_update(t)` | 删除`s`中同时在`t`中的所有项目。 |
| `s.discard(item)` | 从`s`中删除`item`。 |
| `s.intersection_update(t)` | 删除`s`中不在`s`和`t`交叉点的所有项目。 |
| `s.pop()` | 从`s`返回并删除任意项。 |
| `s.remove(item)` | 从`s`中删除项目。 |
| `s.symetric_difference_update(t)` | 删除`s`中不在`s`和`t`对称差中的所有项目。 |
| `s.update(t)` | 将 iterable 对象`t`中的所有项添加到`s`。 |

以下示例演示了一些简单的集合操作及其结果：

![](assets/d88b36c1-aa41-41c2-9b37-f993f4ad831b.png)

请注意，集合对象并不关心其成员是否都属于同一类型，只要它们都是不可变的。如果试图在集合中使用易变对象（如列表或字典），将收到不可损坏的类型错误。所有可哈希类型都有一个哈希值，该值在实例的整个生命周期内不会更改。所有内置的不可变类型都是可散列的。所有内置可变类型都不可散列，因此它们不能用作集合的元素或字典的键。

请注意，在前面的代码中，当我们打印出`s1`和`s2,`的并集时，只有一个元素的值为`'ab'`。这是集合的自然属性，因为集合不包含重复项。

除了这些内置方法之外，我们还可以对集合执行许多其他操作。例如，要测试集合的成员资格，请使用以下命令：

![](assets/c07a377c-bd0d-42fd-b1b4-623b86e62806.png)

我们可以使用以下方法循环集合中的元素：

![](assets/fb5a73b8-3149-43f2-a840-27572d054b26.png)

# 不变集

Python 有一个名为`frozenset`的不可变集合类型。除了不允许改变值的方法或操作，例如`add()`或`clear()`方法之外，它的工作原理与`set`非常相似。这种不变性有几种有用的方法。例如，由于普通集是可变的，因此不可散列，因此它们不能用作其他集的成员。另一方面，`frozenset`是不可变的，因此可以用作集合的成员：

![](assets/be2b1061-aec8-4528-b110-f56652734021.png)

另外，`frozenset`的不可变属性意味着我们可以将其用于`key`到字典，例如：

![](assets/7c63aba3-1ac8-4056-afe3-39e683cbb162.png)

# 数据结构和算法模块

除了内置类型之外，我们还可以使用几个 Python 模块来扩展这些内置类型和函数。在许多情况下，这些 Python 模块可以提供效率和编程优势，从而简化代码。

到目前为止，我们已经研究了字符串、列表、集合和字典的内置数据类型以及`decimal`和`fractions`模块。它们通常用术语**抽象数据类型**（**ADT**来描述。ADT 可被视为可对数据执行的一组操作的数学规范。它们是由它们的行为而不是它们的实现来定义的。除了我们已经研究过的 ADT 之外，还有几个 Python 库为内置数据类型提供扩展。这些将在下一节中讨论。

# 收藏

`collections`模块为内置数据类型提供了更专业、更高性能的替代方案，以及创建命名元组的实用函数。下表列出了“集合”模块的数据类型和操作及其说明：

| **数据类型或操作** | **说明** |
| `namedtuple()` | 创建具有命名字段的元组子类。 |
| `deque` | 带有快速附件的列表，并在任意一端弹出。 |
| `ChainMap` | 类创建多个映射的单个视图。 |
| `Counter` | 用于计算哈希对象的字典子类。 |
| `OrderedDict` | 记住条目顺序的字典子类。 |
| `defaultdict` | 调用函数以提供缺失值的字典子类。 |
| `UserDict``UserList``UserString` | 这三种数据类型只是其底层基类的包装器。它们的使用在很大程度上已被直接对各自的基类进行子类化的能力所取代。可用于作为属性访问基础对象。 |

# 双向队列

双端队列或 DEQUE（通常发音为*deck*）是类似列表的对象，支持线程安全、内存高效的附件。DEQUE 是可变的，支持列表的一些操作，例如索引。Deques 可以通过索引进行分配，如`dq[1] = z`；但是，我们不能直接对 deques 进行切片。例如，`dq[1:2]`产生`TypeError`（我们将很快研究一种从`deque`返回切片作为列表的方法）。

与列表相比，deque 的主要优势在于，在 deque 开头插入项目比在列表开头插入项目快得多，尽管在`deque`结尾插入项目比在列表上的等效操作稍微慢一点。DEQUE 是线程安全的，可以使用`pickle`模块进行序列化。

思考 deques 的一个有用方法是填充和消费项目。DEQUE 中的项目通常从任意一端依次填充和消费：

![](assets/30f68df4-1e85-499a-8db6-794ab3fa1617.png)

我们可以使用`pop()`和`popleft()`方法来消费`deque`中的物品，例如：

![](assets/c1ee966b-9837-452b-b8ef-73a71c2e3167.png)

对于整数*n*的正值，我们也可以使用`rotate(n)`方法将*n*步的所有项目向右移动和旋转，对于负值 n，我们可以使用正整数作为参数向左移动和旋转，例如：

![](assets/acb3a6fd-04c6-4ca2-956a-038e4d9f6408.png)

请注意，我们可以使用`rotate`和`pop`方法删除所选元素。还有一种简单的方法值得了解，它可以返回一个 deque 片段，作为一个列表，如下所示：

![](assets/971cc813-6a43-4000-a609-9f1126a3ccf1.png)

`itertools.islice`方法的工作方式与 slice 在列表上的工作方式相同，不同之处在于它不是将列表作为参数，而是将 iterable 作为列表，并通过开始和停止索引返回选定的值。

deques 的一个有用特性是，它们支持一个`maxlen`可选参数，该参数限制`deque`的大小。这使得它非常适合称为**循环缓冲区**的数据结构。这是一个固定大小的结构，有效地端到端连接，通常用于缓冲数据流。以下是一个基本示例：

```
dq2=deque([],maxlen=3) 
for i in range(6): 
    dq2.append(i) 
    print(dq2) 
```

这将打印出以下内容：

![](assets/60c26be4-3210-40fc-9ac2-5c09a3c9e478.png)

在本例中，我们从右侧填充，从左侧消费。请注意，一旦缓冲区已满，将首先使用最旧的值，并从右侧替换值。我们将通过实现循环列表，在[第 4 章](04.html)、*列表和指针结构*中再次介绍循环缓冲区。

# 链图

`collections.chainmap`类是在 Python3.2 中添加的，它提供了一种链接大量字典或其他映射的方法，以便将它们视为一个对象。此外，还有一个`maps`属性、一个`new_child()`方法和一个`parents`属性。`ChainMap`对象的底层映射存储在一个列表中，可以使用`maps[*i*]`属性检索`ith`字典。请注意，尽管字典本身是无序的，但链映射是字典的有序列表。`ChainMap`在我们使用大量包含相关数据的词典的应用程序中非常有用。消费应用程序需要具有优先级的数据，如果两个字典中的同一个键出现在基础列表的开头，则会被赋予优先级。`ChainMap`通常用于模拟嵌套上下文，例如当我们有多个覆盖配置设置时。以下示例演示了`ChainMap`的一个可能用例：

![](assets/cd18f226-1508-42a8-ba3f-bbc174608006.png)

使用链图而不仅仅是字典的优点是我们保留了以前设置的值。添加子上下文将覆盖同一键的值，但不会将其从数据结构中删除。当我们可能需要保存更改记录以便可以轻松回滚到以前的设置时，这非常有用。

通过为`map()`方法提供适当的索引，我们可以检索和更改任何字典中的任何值。此索引表示链映射中的词典。此外，我们还可以通过`parents()`方法检索父设置，即默认设置：

![](assets/4d6986bb-60b2-4ca6-87f1-c166665226fc.png)

# 反对象

计数器是字典的一个子类，其中每个字典`key`是一个可散列对象，关联值是该对象的整数计数。有三种方法可以初始化计数器。我们可以将任何序列对象、`key:value`对字典或`(object = value, ...)`格式的元组传递给它，例如：

![](assets/b752ec41-6e0d-46fa-838a-babf62d5260b.png)

我们还可以创建一个空的计数器对象，并通过将其`update`方法传递给 iterable 或 dictionary 来填充它，例如：

![](assets/e8a47d3d-2424-4212-a2f0-b7be666915ab.png)

注意`update`方法如何添加计数，而不是用新值替换它们。填充计数器后，我们可以使用与字典相同的方式访问存储值，例如：

![](assets/7845bed2-5ebb-4a39-b801-addddb4e2eb9.png)

计数器对象和字典之间最显著的区别是，计数器对象返回丢失项的零计数，而不是引发`key`错误，例如：

![](assets/2c5c9194-16fb-4369-9bd9-50c02ef26634.png)

我们可以使用`Counter`对象的`elements()`方法创建一个迭代器。这将返回一个迭代器，其中不包括小于 1 的计数，并且顺序不保证。在下面的代码中，我们执行一些更新，从`Counter`元素创建一个迭代器，并使用`sorted()`按字母顺序对键进行排序：

![](assets/33d3968f-3386-43ee-bf4a-0f67763cf426.png)

另外两种值得一提的对抗方法是`most_common()`和`subtract()`。最常用的方法采用正整数参数，该参数确定要返回的最常用元素的数量。元素作为`(key ,value)`元组列表返回。`subtract`方法的工作原理与 update 完全相同，不同之处在于它不增加值，而是减去值，例如：

![](assets/6e3305ae-28de-4cff-8dcb-15e7b341f5dc.png)

# 有序词典

关于有序字典，重要的是它们记住了插入顺序，所以当我们对它们进行迭代时，它们会按照插入顺序返回值。这与普通字典不同，普通字典的顺序是任意的。当我们测试两个字典是否相等时，这种相等仅基于它们的键和值；然而，对于`OrderedDict`，插入顺序也被视为具有相同键和值但不同插入顺序将返回`False`的两个`OrderedDicts`之间的相等性测试：

![](assets/63631d72-b531-4a68-b8e1-635db3f0dcf1.png)

类似地，当我们使用`update`从列表中添加值时，`OrderedDict`将保持与列表相同的顺序。这是迭代值时返回的顺序，例如：

![](assets/04d03c69-dba7-4264-a8ca-c58b8597e31c.png)

`OrderedDict`通常与 sorted 方法结合使用，以创建排序字典。例如，在下面的示例中，我们使用`lambda`函数对值进行排序，这里我们使用数值表达式对整数值进行排序：

![](assets/d9074136-7df4-4217-a71a-0f92e148f442.png)

# 默认命令

`defaultdict`对象是`dict`的子类，因此它们共享方法和操作。它是初始化字典的一种方便方法。有了`dict`，Python 在试图访问字典中还没有的密钥时会抛出一个`KeyError`。`defaultdict`重写一个方法`__missing__(key)`，并创建一个新的实例变量`default_factory`。使用`defaultdict`时，它不会抛出错误，而是运行作为`default_factory`参数提供的函数，该函数将生成一个值。`defaultdict`的一个简单用法是将`default_factory`设置为`int`并使用它快速统计字典中项目的计数，例如：

![](assets/4aacc08f-6ac6-4bd8-ba58-b282cf6cec45.png)

您会注意到，如果我们尝试使用普通字典执行此操作，则在尝试添加第一个键时，会出现一个键错误。我们作为 default`dict`的参数提供的`int`实际上是只返回零的函数`int()`。当然，我们可以创建一个函数来确定字典的值。例如，如果提供的参数是原色，即红色、绿色或蓝色，则以下函数返回`True`，否则返回`False`：

```
def isprimary(c):  
    if (c == 'red') or (c == 'blue') or (c == 'green'):  
        return True  
    else: 
        return False 
```

我们现在可以创建一个新的`defaultdict`对象，并使用`isprimary`函数填充它：

![](assets/28788093-ffe4-444d-b88d-61d3a0f176a7.png)

# 命名元组

`namedtuple`方法返回一个类似元组的对象，该对象的字段可以通过命名索引以及普通元组的整数索引访问。这允许代码在一定程度上是自文档化的，并且更具可读性。它在有大量元组的应用程序中特别有用，我们需要轻松跟踪每个元组代表的内容。`namedtuple`继承`tuple`的方法，与`tuple`向后兼容。

字段名作为逗号和/或空格分隔的值传递给`namedtuple`方法。它们也可以作为字符串序列传递。字段名是单个字符串，可以是任何不以数字或下划线开头的合法 Python 标识符。此处显示了一个典型示例：

![](assets/1920ff3f-ef01-473f-a35f-4e6559a02ab4.png)

`namedtuple`方法采用两个可选的布尔参数，`verbose`和`rename`。当`verbose`设置为`True`时，类定义在构建时打印。此参数被贬低，而倾向于使用`__source`属性。当`rename`参数设置为`True`时，任何无效的字段名将自动替换为位置参数。例如，我们尝试使用`def`作为字段名。这通常会生成一个错误，但是由于我们已经将`rename`分配给`True`，Python 解释器允许这样做。然而，当我们试图查找`def`值时，我们得到了一个语法错误，因为`def`是一个保留关键字。非法字段名已替换为通过向位置值添加下划线创建的字段名：

![](assets/8cfa1ac4-48e3-418c-9367-74f9239595b5.png)

除了继承的元组方法外，命名的元组还定义了自己的三个方法，`_make()`、`asdict()`和`_replace`。这些方法以下划线开头，以防止与字段名发生潜在冲突。`_make()`方法将 iterable 作为参数，并将其转换为命名元组对象，例如：

![](assets/e401ef47-ccc6-480d-b2f7-6a028ec75264.png)

`_asdict`方法返回一个`OrderedDict`，其中字段名映射到索引键，值映射到字典值，例如：

![](assets/21b7a0f1-9af8-421e-9047-d8e9e0e24040.png)

`_replace`方法返回元组的新实例，替换指定的值，例如：

```
In[82]:  sl._replace(x=7, z=9)
Out[82]: space2 (x=7, _l=4, z=9)
```

# 阵列

数组模块定义了一个数据类型`array`，该数据类型与`list`数据类型相似，只是其内容必须是基础表示的单一类型，这是由机器体系结构或基础 C 实现决定的。

数组的类型在创建时确定，并由以下类型代码之一指示：

| 密码 | C 型 | Python 类型 | 最小字节数 |
| `'b'` | `signed char` | `int` | 1. |
| `'B'` | `unsigned char` | `int` | 1. |
| `'u'` | `Py_UNICODE` | `Unicode character` | 2. |
| `'h'` | `signed short` | `int` | 2. |
| `'H'` | `unsigned short` | `int` | 2. |
| `'i'` | `signed int` | `int` | 2. |
| `'I'` | `unsigned int` | `int` | 2. |
| `'l'` | `signed long` | `int` | 4. |
| `'L'` | `unsigned long` | `int` | 8. |
| `'q'` | `signed long long` | `int` | 8. |
| `'Q'` | `unsigned lon long` | `int` | 8. |
| `'f'` | `float` | `float` | 4. |
| `'d'` | `double` | `float` | 8. |

阵列对象支持以下属性和方法：

| 属性或方法 | 描述 |
| `a.typecode` | 用于创建数组的类型码字符。 |
| `a.itemsize` | 数组中存储的项的大小（以字节为单位）。 |
| `a.append(x)` | 将项目`x`追加到数组末尾。 |
| `a.buffer_info()` | 返回用于存储数组的缓冲区的内存位置和长度。 |
| `a.byteswap()` | 交换每个项的字节顺序。用于以不同的字节顺序写入机器或文件。 |
| `a.count(x)` | 返回`a`中`x`的出现次数。 |
| `a.extend(b)` | 将任何可数`b`追加到数组`a`的末尾。 |
| `a.frombytes(s)` | 将字符串`s`中的项作为机器值数组追加。 |
| `a.fromfile(f, n)` | 从文件对象`f`中读取`n`项作为机器值，并将其附加到`a`。如果`n`中的项目少于`n`，则引发`EOFError`。 |
| `a.fromlist(l)` | 添加列表`l`中的项目。 |
| `a.fromunicode(s)` | 使用 unicode 字符串`s`扩展`a`。数组`a`必须是`u`类型，否则`ValueError`被提升。 |
| `index(x)` | 返回项目`x.`的第一个（最小）索引 |
| `a.insert(i, x)` | 在索引`i.`之前插入项目`x` |
| `a.pop([i])` | 删除并返回索引为`i`的项目。如果未指定，则默认为最后一项`(i = -1)`。 |
| `a.remove(x)` | 删除第一次出现的项目`x`。 |
| `a.reverse()` | 反转项目的顺序。 |
| `a.tobytes()` | 将数组转换为机器值并返回字节表示形式。 |
| `a.tofile(f)` | 将所有项目作为机器值写入文件对象`f`。 |
| `a.tolist()` | 将数组转换为列表。 |
| `a.tounicode()` | 将数组转换为`unicode`字符串。数组类型必须为`'u'`否则会引发`ValueError`。 |

数组对象支持所有常规序列操作，如索引、切片、串联和乘法。

与列表相反，使用数组是存储所有相同类型数据的更有效的方法。在下面的示例中，我们创建了一个 0 到 100 万减去 1 的整数数组，以及一个相同的列表。在整数数组中存储 100 万个整数需要相当于一个列表 45%的内存：

![](assets/783d78a5-9b56-41df-8a33-296e15225f29.png)

因为我们对节省空间感兴趣，也就是说，我们正在处理大型数据集和有限的内存大小，所以我们通常对阵列执行就地操作，并且只在需要时创建副本。通常，枚举用于对每个元素执行操作。在以下代码段中，我们将执行向数组中的每个项添加一个的简单操作：

![](assets/e86acdfe-d53c-4254-95dc-bcf8e6fbb6fc.png)

应该注意的是，在对创建列表的数组执行操作（如列表理解）时，首先使用数组的内存效率增益将被抵消。当我们需要创建新的数据对象时，解决方案是使用生成器表达式来执行操作，例如：

![](assets/cabf478a-d730-4011-85b8-55bef7d2caa0.png)

使用此模块创建的数组不适用于需要向量运算矩阵的工作。在下一章中，我们将构建自己的抽象数据类型来处理这些操作。对于数值计算来说，`NumPy`扩展也很重要，可在[www.numpy.org](http://www.numpy.org)上找到。

# 总结

在最后两章中，我们研究了 Python 的语言特性和数据类型。我们已经研究了内置数据类型和一些内部 Python 模块，最显著的是 collections 模块。还有其他几个与本书主题相关的 Python 模块，但与其单独研究它们，不如在我们开始使用它们时，它们的用法和功能就不言而喻了。还有一些外部库，比如 SciPy 堆栈，同样，在我们开始应用它们时，我将尝试解释它们的基本功能。

在下一章中，我们将介绍算法设计的基本理论和技术。